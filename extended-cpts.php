<?php
/*
Plugin Name:  Extended CPTs
Description:  Extended custom post types.
Version:      2.1.4
Author:       John Blackbourn
Author URI:   http://johnblackbourn.com

Extended CPTs provides extended functionality to custom post types in WordPress, allowing you to quickly build custom post types without having to write the same code again and again.

= Improved defaults =

 * Public post type with admin UI enabled
 * Intelligent values for labels and post updated messages
 * Hierarchical with page capability type
 * Drop with_front from rewrite rules
 * Support post thumbnails
 * Optimal menu placement

= Extended features =

 * Ridiculously easy custom admin columns:
   - Add columns for post meta, taxonomy terms, post fields, featured image, and callback functions
   - Add columns depending on user capabilities
   - Out of the box sorting by post meta, taxonomy terms, and post fields
   - Specify a default sort column and sort order
 * Custom admin screen filters for post meta and taxonomy terms
 * Easily override any query variables such as posts_per_page, orderby, order and nopaging
 * Add post type archives to the nav menu screen
 * Add CPTs to the site's main feed
 * Add CPTs to the 'Right Now' section on the dashboard

= @TODO =

 * Improve the selection of fields in the Quick Edit boxes
 * Allow checkbox, radio and text input admin screen filters
 * Allow overriding of post updated messages via the $args parameter
 * Make column titles optional and generate them

= License =

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

*/


/**
 * Wrapper function for instantiating a new ExtendedCPT object. This is the only function you need.
 * See the ExtendedCPT class constructor for parameters.
 */
function register_extended_post_type( $post_type, $args = array(), $plural = null, $slug = null ) {
	return new ExtendedCPT( $post_type, $args, $plural, $slug );
}

class ExtendedCPT {

	/**
	 * Default arguments for custom post types.
	 * Many of these are different from those found in WordPress' register_post_type() function.
	 *
	 * @var array
	 */
	protected $defaults = array(
		'public'               => true,
		'publicly_queryable'   => true,
		'exclude_from_search'  => false,
		'show_ui'              => true,
		'show_in_menu'         => true,
		'menu_position'        => 6,
		'menu_icon'            => null,
		'capability_type'      => 'page',
		'hierarchical'         => true,
		'supports'             => array( 'title', 'editor', 'thumbnail' ),
		'has_archive'          => true,
		'query_var'            => true,
		'can_export'           => true,
		'show_in_nav_menus'    => true,
		'archive_in_nav_menus' => true,  # Custom arg
		'right_now'            => false, # Custom arg
		'show_in_feed'         => false, # Custom arg
		'archive'              => null,  # Custom arg
		'cols'                 => null,  # Custom arg
		'filters'              => null,  # Custom arg
	);

	/**
	 * Some other member variables you don't need to worry about:
	 */
	protected $post_type;
	protected $post_slug;
	protected $post_singular;
	protected $post_plural;
	protected $post_singular_low;
	protected $post_plural_low;
	protected $args;
	protected $_cols;

	/**
	 * Class constructor.
	 *
	 * The $post_type parameter is used as the post type name and to build the post type labels. This
	 * means you can create a post type with just one parameter and all labels and post updated messages
	 * will be generated for you. Example:
	 *
	 * register_extended_post_type( 'event' );
	 *
	 * The plural name for a post type is generated by appending an 's' to $post_type. You can override
	 * this with the $plural parameter if necessary. Example:
	 *
	 * register_extended_post_type( 'person', array(), 'people' );
	 *
	 * The post type slug is generated from the plural (which is either $post_type appended with 's' or
	 * the $plural parameter). This can be overridden with the $slug parameter if necessary. Example:
	 *
	 * register_extended_post_type( 'person', array(), 'people', 'meet-the-team' );
	 *
	 * The $args parameter accepts all the standard arguments for register_post_type() in addition to
	 * several custom arguments that provide extended functionality:
	 *
	 * - archive_in_nav_menus - boolean - Whether to show an 'All Items' checkbox for this post type on
	 * the nav menus screen so the post type archive can easily be added to a nav menu without manually
	 * adding a custom link. Uses the 'all_items' label for the nav menus screen checkbox and the 'name'
	 * label for the actual menu item. Defaults to true. Only used if show_in_nav_menus and has_archive
	 * are both also true.
	 *
	 * - right_now - boolean - Whether to show this post type on the 'Right Now' section of WordPress'
	 * dashboard. Defaults to false.
	 *
	 * - show_in_feed - boolean - Whether to include this post type in the site's main feed. Defaults to
	 * false.
	 *
	 * - archive - array - Associative array of query vars to override on this post type's archive.
	 * Handy for setting 'no_paging' to true, for example. Defaults to null (no overridden query vars).
	 *
	 * - cols - array - Associative array of admin columns to show for this post type. See the cols()
	 * method of this class for more information. Defaults to null (no custom columns).
	 *
	 * - filters - array - Associative array of admin filters to show for this post type. See the
	 * filters() method of this class for more information. Defaults to null (no custom filters).
	 *
	 * @param string $post_type The post type name
	 * @param array $args The post type arguments (optional)
	 * @param string $plural The post type plural name (optional)
	 * @param string $slug The post type slug (optional)
	 * @return null
	 */
	public function __construct( $post_type, $args = array(), $plural = null, $slug = null ) {

		if ( $slug )
			$this->post_slug = $slug;
		else if ( $plural )
			$this->post_slug = $plural;
		else
			$this->post_slug = $post_type . 's';

		if ( $plural )
			$this->post_plural = $plural;
		else
			$this->post_plural = $this->post_slug;

		$this->post_type = strtolower( $post_type );
		$this->post_slug = strtolower( $this->post_slug );

		# Build our base post type names:
		$this->post_singular     = ucwords( str_replace( array( '-', '_' ), ' ', $post_type ) );
		$this->post_plural       = ucwords( str_replace( array( '-', '_' ), ' ', $this->post_plural ) );
		$this->post_singular_low = strtolower( $this->post_singular );
		$this->post_plural_low   = strtolower( $this->post_plural );

		# Build our labels:
		$this->defaults['labels'] = array(
			'name'               => $this->post_plural,
			'singular_name'      => $this->post_singular,
			'menu_name'          => $this->post_plural,
			'name_admin_bar'     => $this->post_singular,
			'add_new'            => 'Add New',
			'add_new_item'       => sprintf( 'Add New %s', $this->post_singular ),
			'edit_item'          => sprintf( 'Edit %s', $this->post_singular ),
			'new_item'           => sprintf( 'New %s', $this->post_singular ),
			'view_item'          => sprintf( 'View %s', $this->post_singular ),
			'search_items'       => sprintf( 'Search %s', $this->post_plural ),
			'not_found'          => sprintf( 'No %s found', $this->post_plural_low ),
			'not_found_in_trash' => sprintf( 'No %s found in trash', $this->post_plural_low ),
			'parent_item_colon'  => sprintf( 'Parent %s', $this->post_singular ),
			'all_items'          => sprintf( 'All %s', $this->post_plural ),
		);

		# 'public' is a meta argument, so set some defaults if it's present:
		if ( isset( $args['public'] ) ) {
			$this->defaults['publicly_queryable']  =  $args['public'];
			$this->defaults['show_ui']             =  $args['public'];
			$this->defaults['show_in_menu']        =  $args['public'];
			$this->defaults['show_in_nav_menus']   =  $args['public'];
			$this->defaults['exclude_from_search'] = !$args['public'];
		}

		# 'show_ui' is a meta argument, so set some defaults if it's present:
		if ( isset( $args['show_ui'] ) )
			$this->defaults['show_in_menu'] = $args['show_ui'];

		# Only set rewrites if we need them
		if ( ( isset( $args['publicly_queryable'] ) and !$args['publicly_queryable'] ) or ( !$this->defaults['publicly_queryable'] ) ) {
			$this->defaults['rewrite'] = false;
		} else {
			$this->defaults['rewrite'] = array(
				'slug'       => $this->post_slug,
				'with_front' => false
			);
		}

		# Merge our args with the defaults:
		$this->args = wp_parse_args( $args, $this->defaults );

		# I can't remember why this is here, but it needs to be here:
		if ( !isset( $args['exclude_from_search'] ) )
			$this->args['exclude_from_search'] = !$this->args['publicly_queryable'];

		# This allows the 'labels' arg to contain some, none or all labels:
		if ( isset( $args['labels'] ) )
			$this->args['labels'] = wp_parse_args( $args['labels'], $this->defaults['labels'] );

		if ( is_admin() ) {

			# Admin columns:
			if ( $this->args['cols'] ) {
				add_filter( 'manage_posts_columns',                            array( $this, '_log_default_cols' ), 0 );
				add_filter( "manage_edit-{$this->post_type}_sortable_columns", array( $this, 'sortables' ) );
				add_filter( "manage_{$this->post_type}_posts_columns",         array( $this, 'cols' ) );
				add_action( "manage_{$this->post_type}_posts_custom_column",   array( $this, 'col' ), 10, 2 );
				add_action( 'load-edit.php',                                   array( $this, 'default_sort' ) );
				add_action( 'load-edit.php',                                   array( $this, 'maybe_sort' ) );
			}

			# Admin filters:
			if ( $this->args['filters'] ) {
				add_action( 'load-edit.php', array( $this, 'maybe_filter' ) );
				add_filter( 'query_vars',    array( $this, 'add_filter_query_vars' ) );
			}

			# 'Right Now' dashboard widget:
			if ( $this->args['right_now'] )
				add_action( 'right_now_content_table_end', array( $this, 'right_now' ) );

			# Nav menus screen item:
			if ( $this->args['archive_in_nav_menus'] and $this->args['show_in_nav_menus'] and $this->args['has_archive'] )
				add_action( "nav_menu_items_{$this->post_type}", array( $this, 'nav_menu_items' ), 10, 3 );

			# Post updated messages:
			add_filter( 'post_updated_messages',      array( $this, 'post_updated_messages' ), 1 );
			add_filter( 'bulk_post_updated_messages', array( $this, 'bulk_post_updated_messages' ), 1, 2 );

		} else {

			# Post type in the site's main feed:
			if ( $this->args['show_in_feed'] )
				add_filter( 'request', array( $this, 'add_to_feed' ) );

			# Post type archive query var overrides:
			if ( $this->args['archive'] )
				add_filter( 'parse_request', array( $this, 'override_private_query_vars' ), 1 );

		}

		# Register post type when WordPress initialises:
		if ( 'init' === current_filter() )
			call_user_func( array( $this, 'register_post_type' ) );
		else
			add_action( 'init', array( $this, 'register_post_type' ), 9 );

	}

	/**
	 * Set the default sort field and sort order on our post type admin screen.
	 *
	 * @return null
	 */
	public function default_sort() {

		if ( $this->post_type != get_current_screen()->post_type )
			return;

		# If we've already ordered the screen, bail out:
		if ( isset( $_GET['orderby'] ) )
			return;

		# Loop over our columns to find the default sort column (if there is one):
		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_array( $col ) and isset( $col['default'] ) ) {
				$_GET['orderby'] = $id;
				$_GET['order'] = ( 'desc' == strtolower( $col['default'] ) ? 'desc' : 'asc' );
				break;
			}
		}

	}

	/**
	 * Add the relevant filters for sorting posts by our sortable fields.
	 *
	 * @return null
	 */
	public function maybe_sort() {

		if ( $this->post_type != get_current_screen()->post_type )
			return;

		add_filter( 'request',       array( $this, 'sort_posts_by_post_meta' ) );
		add_filter( 'request',       array( $this, 'sort_posts_by_post_field' ) );
		add_filter( 'posts_clauses', array( $this, 'sort_posts_by_taxonomy' ), 10, 2 );

	}

	/**
	 * Add the relevant filters for filtering posts by our custom filters.
	 *
	 * @return null
	 */
	public function maybe_filter() {

		if ( $this->post_type != get_current_screen()->post_type )
			return;

		add_filter( 'request',               array( $this, 'filter_posts_by_post_meta' ) );
		add_action( 'restrict_manage_posts', array( $this, 'filters' ) );

	}

	/**
	 * Output custom filter dropdown menus on the admin screen for this post type.
	 *
	 * Each item in the 'filters' array is an associative array of information for a filter. Defining a
	 * filter is easy. Just define an array which includes the filter title and filter type. You can
	 * display filters for post meta fields and taxonomy terms.
	 * 
	 * The example below adds filters for the 'event_type' meta key and the 'location' taxonomy:
	 * 
	 * register_extended_post_type( 'event', array(
	 *     'filters' => array(
	 *         'event_type' => array(
	 *             'title'    => 'Event Type',
	 *             'meta_key' => 'event_type'
	 *         ),
	 *         'event_location' => array(
	 *             'title'    => 'Location',
	 *             'taxonomy' => 'location'
	 *         )
	 *     )
	 * ) );
	 * 
	 * That's all you need to do. WordPress handles taxonomy term filtering itself (the plugin just
	 * outputs the dropdown), and the plugin handles the dropdown menu and filtering for post meta.
	 * 
	 * Each item in the 'filters' array needs either a 'taxonomy' or 'meta_key' element containing the
	 * corresponding taxonomy name or post meta key.
	 *
	 * There are a couple of optional elements:
	 * 
	 * - title - The filter title. If omitted, the title will use the all_items taxonomy label or a
	 * formatted version of the post meta key.
	 *
	 * - cap - A capability required in order for this filter to be displayed to the current user. Defaults
	 * to null, meaning the filter is shown to all users.
	 *
	 * @TODO Docs for the meta_exists filter
	 *
	 * @return null
	 */
	public function filters() {

		global $wpdb;

		$pto = get_post_type_object( $this->post_type );

		foreach ( $this->args['filters'] as $filter_key => $filter ) {

			if ( isset( $filter['cap'] ) and !current_user_can( $filter['cap'] ) )
				continue;

			if ( isset( $filter['taxonomy'] ) ) {

				$tax = get_taxonomy( $filter['taxonomy'] );

				# For this, we need the dropdown walker from Extended Taxonomies:
				if ( !class_exists( $class = 'Walker_ExtendedTaxonomyDropdownSlug' ) )
					return trigger_error( sprintf( __( 'The %s class was not found', 'ext_cpts' ), $class ), E_USER_WARNING );
				else
					$walker = new Walker_ExtendedTaxonomyDropdownSlug;

				# If we haven't specified a title, use the all_items label from the taxonomy:
				if ( !isset( $filter['title'] ) )
					$filter['title'] = $tax->labels->all_items;

				# Output the dropdown:
				wp_dropdown_categories( array(
					'show_option_all' => $filter['title'] . '&nbsp;',
					'hide_empty'      => false,
					'hierarchical'    => true,
					'show_count'      => false,
					'orderby'         => 'name',
					'selected'        => get_query_var( $filter['taxonomy'] ),
					'id'              => 'filter_' . $filter_key,
					'name'            => $filter['taxonomy'],
					'taxonomy'        => $filter['taxonomy'],
					'walker'          => $walker
				) );

			} else if ( isset( $filter['meta_key'] ) ) {

				# If we haven't specified a title, generate one from the meta key:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = str_replace( array( '-', '_' ), ' ', $filter['meta_key'] );
					$filter['title'] = ucwords( $filter['title'] ) . 's';
					$filter['title'] = sprintf( __( 'All %s', 'ext_cpts' ), $filter['title'] );
				}

				# Fetch all the values for our meta key:
				$meta_values = $wpdb->get_col( $wpdb->prepare( "
					SELECT DISTINCT meta_value
					FROM {$wpdb->postmeta} as m
					JOIN {$wpdb->posts} as p ON ( p.ID = m.post_id )
					WHERE m.meta_key = %s
					AND m.meta_value != ''
					AND p.post_type = %s
					ORDER BY m.meta_value ASC
				", $filter['meta_key'], $this->post_type ) );

				$selected = stripslashes( get_query_var( $filter_key ) );

				# Output the dropdown:
				?>
				<select name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>">
					<option value=""><?php echo esc_html( $filter['title'] ); ?>&nbsp;</option>
					<?php foreach ( $meta_values as $v ) { ?>
						<option value="<?php echo esc_attr( $v ); ?>" <?php selected( $selected, $v ); ?>><?php echo esc_html( $v ); ?></option>
					<?php } ?>
				</select>
				<?php

			} else if ( isset( $filter['meta_exists'] ) ) {

				# If we haven't specified a title, use the all_items label from the post type:
				if ( !isset( $filter['title'] ) )
					$filter['title'] = $pto->labels->all_items;

				$selected = stripslashes( get_query_var( $filter_key ) );

				# Output the dropdown:
				?>
				<select name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>">
					<option value=""><?php echo esc_html( $filter['title'] ); ?>&nbsp;</option>
					<?php foreach ( $filter['meta_exists'] as $v => $t ) { ?>
						<option value="<?php echo esc_attr( $v ); ?>" <?php selected( $selected, $v ); ?>><?php echo esc_html( $t ); ?></option>
					<?php } ?>
				</select>
				<?php

			}

		}

	}

	/**
	 * Add our post meta filter names to the public query vars.
	 *
	 * @param array $vars Public query variables
	 * @return array Updated public query variables
	 */
	public function add_filter_query_vars( $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {
			if ( isset( $filter['meta_key'] ) or isset( $filter['meta_exists'] ) )
				$vars[] = $filter_key;
		}

		return $vars;

	}

	/**
	 * Add our post meta filters to the request parameters.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function filter_posts_by_post_meta( $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {
			if ( isset( $filter['meta_key'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				$vars['meta_query'][] = array(
					'key'   => $filter['meta_key'],
					'value' => stripslashes( $vars[$filter_key] )
				);
			} else if ( isset( $filter['meta_exists'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				$vars['meta_query'][] = array(
					'key'     => stripslashes( $vars[$filter_key] ),
					'compare' => 'NOT IN',
					'value'   => array( '', '0', 'false', 'null' )
				);
			}
		}

		return $vars;

	}

	/**
	 * Add our post type to the 'Right Now' widget on WordPress' dashboard.
	 *
	 * @return null
	 */
	public function right_now() {

		# Get the labels and format the counts:
		$pto   = get_post_type_object( $this->post_type );
		$count = wp_count_posts( $this->post_type );
		$text  = $this->n( $pto->labels->singular_name, $pto->labels->name, $count->publish );
		$num   = number_format_i18n( $count->publish );

		# Add edit links if the user has permissions:
		if ( current_user_can( $pto->cap->edit_posts ) ) {
			$num  = '<a href="edit.php?post_type=' . $this->post_type . '">' . $num . '</a>';
			$text = '<a href="edit.php?post_type=' . $this->post_type . '">' . $text . '</a>';
		}

		# Output it:
		echo '<tr>';
		echo '<td class="first b b-' . $this->post_type . '">' . $num . '</td>';
		echo '<td class="t ' . $this->post_type . '">' . $text . '</td>';
		echo '</tr>';

	}

	/**
	 * Add our post type updated messages.
	 *
	 * The messages are as follows:
	 *
	 *   1 => "Post updated. {View Post}"
	 *   2 => "Custom field updated."
	 *   3 => "Custom field deleted."
	 *   4 => "Post updated."
	 *   5 => "Post restored to revision from [date]."
	 *   6 => "Post published. {View post}"
	 *   7 => "Post saved."
	 *   8 => "Post submitted. {Preview post}"
	 *   9 => "Post scheduled for: [date]. {Preview post}"
	 *  10 => "Post draft updated. {Preview post}"
	 *
	 * @param array $messages An associative array of post updated messages with post type as keys.
	 * @return array Updated array of post updated messages.
	 */
	public function post_updated_messages( $messages ) {

		global $post;

		$messages[$this->post_type] = array(
			1 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s updated. <a href="%2$s">View %3$s</a>' : '%1$s updated.' ),
				$this->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			2 => 'Custom field updated.',
			3 => 'Custom field deleted.',
			4 => sprintf( '%s updated.',
				$this->post_singular
			),
			5 => isset( $_GET['revision'] ) ? sprintf( '%1$s restored to revision from %2$s',
				$this->post_singular,
				wp_post_revision_title( intval( $_GET['revision'] ), false )
			) : false,
			6 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s published. <a href="%2$s">View %3$s</a>' : '%1$s published.' ),
				$this->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			7 => sprintf( '%s saved.',
				$this->post_singular
			),
			8 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s submitted. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s submitted.' ),
				$this->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->post_singular_low
			),
			9 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s scheduled for: <strong>%2$s</strong>. <a target="_blank" href="%3$s">Preview %4$s</a>' : '%1$s scheduled for: <strong>%2$s</strong>.' ),
				$this->post_singular,
				date_i18n( 'M j, Y @ G:i', strtotime( $post->post_date ) ),
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			10 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s draft updated. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s draft updated.' ),
				$this->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->post_singular_low
			),
		);

		return $messages;

	}

	/**
	 * Add our bulk post type updated messages.
	 *
	 * These messages are not yet in WordPress core.
	 * @see http://core.trac.wordpress.org/ticket/18710
	 *
	 * The messages are as follows:
	 *
	 *   1 => "Post updated." | "[n] posts updated."
	 *   2 => "Post not updated, somebody is editing it." | "[n] posts not updated, somebody is editing them."
	 *   3 => "Post permanently deleted." | "[n] posts permanently deleted."
	 *   4 => "Post moved to the trash." | "[n] posts moved to the trash."
	 *   5 => "Post restored from the trash." | "[n] posts restored from the trash."
	 *
	 * @param array $messages An associative array of bulk post updated messages with post type as keys.
	 * @return array Updated array of bulk post updated messages.
	 */
	public function bulk_post_updated_messages( $messages, $counts ) {

		$messages[$this->post_type] = array(
			1 => sprintf( $this->n( '%2$s updated.', '%1$s %3$s updated.', $counts[1] ),
				$counts[1],
				$this->post_singular,
				$this->post_plural_low
			),
			2 => sprintf( $this->n( '%2$s not updated, somebody is editing it.', '%1$s %3$s not updated, somebody is editing them.', $counts[2] ),
				$counts[2],
				$this->post_singular,
				$this->post_plural_low
			),
			3 => sprintf( $this->n( '%2$s permanently deleted.', '%1$s %3$s permanently deleted.', $counts[3] ),
				$counts[3],
				$this->post_singular,
				$this->post_plural_low
			),
			4 => sprintf( $this->n( '%2$s moved to the trash.', '%1$s %3$s moved to the trash.', $counts[4] ),
				$counts[4],
				$this->post_singular,
				$this->post_plural_low
			),
			5 => sprintf( $this->n( '%2$s restored from the trash.', '%1$s %3$s restored from the trash.', $counts[5] ),
				$counts[5],
				$this->post_singular,
				$this->post_plural_low
			),
		);

		return $messages;

	}

	/**
	 * Sort posts by post meta value.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_post_meta( $vars ) {

		if ( !isset( $vars['orderby'] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']]['meta_key'] ) )
			return $vars;

		$vars['meta_key'] = $this->args['cols'][$vars['orderby']]['meta_key'];
		$vars['orderby']  = 'meta_value';

		return $vars;

	}

	/**
	 * Sort posts by post field.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_post_field( $vars ) {

		if ( !isset( $vars['orderby'] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']]['post_field'] ) )
			return $vars;

		$field = str_replace( 'post_', '', $this->args['cols'][$vars['orderby']]['post_field'] );
		$vars['orderby'] = $field;

		return $vars;

	}

	/**
	 * Sort posts by taxonomy term(s).
	 *
	 * @param array $clauses Request SQL clauses
	 * @param object $q The WP_Query object
	 * @return array Updated request SQL clauses
	 */
	public function sort_posts_by_taxonomy( $clauses, $q ) {

		global $wpdb;

		if ( !isset( $q->query['orderby'] ) )
			return $clauses;
		if ( !isset( $this->args['cols'][$q->query['orderby']]['taxonomy'] ) )
			return $clauses;

		# Taxonomy term ordering courtesy of http://scribu.net/wordpress/sortable-taxonomy-columns.html

		$clauses['join'] .= "
			LEFT OUTER JOIN {$wpdb->term_relationships} as ext_cpts_tr ON ( {$wpdb->posts}.ID = ext_cpts_tr.object_id )
			LEFT OUTER JOIN {$wpdb->term_taxonomy} as ext_cpts_tt ON ( ext_cpts_tr.term_taxonomy_id = ext_cpts_tt.term_taxonomy_id )
			LEFT OUTER JOIN {$wpdb->terms} as ext_cpts_t ON ( ext_cpts_tt.term_id = ext_cpts_t.term_id )
		";
		$clauses['where'] .= $wpdb->prepare( " AND ( taxonomy = %s OR taxonomy IS NULL )", $this->args['cols'][$q->query['orderby']]['taxonomy'] );
		$clauses['groupby'] = 'ext_cpts_tr.object_id';
		$clauses['orderby'] = "GROUP_CONCAT( ext_cpts_t.name ORDER BY name ASC ) ";
		$clauses['orderby'] .= ( 'ASC' == strtoupper( $q->get('order') ) ) ? 'ASC' : 'DESC';

		return $clauses;

	}

	/**
	 * Add our custom columns to the list of sortable columns.
	 *
	 * @param array $cols Associative array of sortable columns
	 * @return array Updated array of sortable columns
	 */
	public function sortables( $cols ) {

		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_array( $col ) and ( isset( $col['meta_key'] ) or isset( $col['taxonomy'] ) or isset( $col['post_field'] ) ) )
				$cols[$id] = $id;
		}

		return $cols;

	}

	/**
	 * Add columns to the admin screen for this post type.
	 *
	 * Each item in the 'cols' array is either a string name of an existing column, or an associative
	 * array of information for a custom column.
	 *
	 * Defining a custom column is easy. Just define an array which includes the column title, column
	 * type, and optional callback function. You can display columns for post meta, taxonomy terms,
	 * post fields, the featured image, and custom functions.
	 * 
	 * The example below adds two columns; one which displays the value of the post's 'event_type' meta
	 * key and one which lists the post's terms from the 'location' taxonomy:
	 * 
	 * register_extended_post_type( 'event', array(
	 *     'cols' => array(
	 *         'event_type' => array(
	 *             'title'    => 'Event Type',
	 *             'meta_key' => 'event_type'
	 *         ),
	 *         'event_location' => array(
	 *             'title'    => 'Location',
	 *             'taxonomy' => 'location'
	 *         )
	 *     )
	 * ) );
	 * 
	 * That's all you need to do. The columns will handle all the sorting and safely outputting the data
	 * (escaping text, and comma-separating taxonomy terms). No more messing about with all of those
	 * annoyingly named column filters and actions.
	 * 
	 * Each item in the 'cols' array should contain:
	 * 
 	 * - A 'title' element containing the column title.
 	 * - One of the following elements which defines which type of column it is:
   	 *     - taxonomy - The name of a taxonomy
   	 *     - meta_key - A post meta key
   	 *     - post_field - The name of a post field (eg. post_excerpt)
	 *     - featured_image - A featured image size (eg. thumbnail)
	 * 
	 * The value for the corresponding taxonomy terms, post meta or post field are safely escaped and output
	 * into the column, and the values are used to provide the sortable functionality for the column. For
	 * featured images, the post's featured image of that size will be displayed if there is one.
	 * 
	 * There are a few optional elements:
	 * 
 	 * - function - The name of a callback function for the column (eg. 'my_function') which gets called
	 * instead of the built-in function for handling that column. Note that it's not passed any parameters,
	 * so it must use the global $post object.
	 *
 	 * - default - Specifies that the admin screen should be sorted by this column by default (instead of
	 * sorting by post date). Can be boolean true (which will be treated as 'asc'), or 'asc' or 'desc' to
	 * explicitly control the default order.
	 *
	 * - width & height - These are only used for the 'featured_image' column type and allow you to set an
	 * explicit width and/or height on the <img> tag. Handy for downsizing the image.
	 * 
	 * - date_format - This is used with the 'meta_key' column type. The value of the meta field will be
	 * treated as a timestamp if this is present (Unix and MySQL timestamp formats are supported in the meta
	 * value). Pass in boolean true to format the date according to the 'Date Format' setting or pass in a
	 * valid date formatting string (eg. 'd/m/Y H:i:s').
	 * 
	 * - cap - A capability required in order for this column to be displayed to the current user. Defaults
	 * to null, meaning the column is shown to all users.
	 *
	 * Remember, in addition to custom columns there are also three columns built in to WordPress which you
	 * can use: 'comments', 'date' and 'author'.
	 *
	 * @TODO Docs for the 'connection' column type.
	 *
	 * @param array $cols Associative array of columns
	 * @return array Updated array of columns
	 */
	public function cols( $cols ) {

		$new_cols = array();
		$keep = array(
			'cb', 'title'
		);

		# Add existing columns we want to keep:
		foreach ( $cols as $id => $title ) {
			if ( in_array( $id, $keep ) and !isset( $this->args['cols'][$id] ) )
				$new_cols[$id] = $title;
		}

		# Add our custom columns:
		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_string( $col ) and isset( $cols[$col] ) ) {
				$new_cols[$col] = $cols[$col];
			} else if ( is_array( $col ) ) {
				if ( isset( $col['cap'] ) and !current_user_can( $col['cap'] ) )
					continue;
				if ( isset( $col['connection'] ) and !function_exists( 'p2p_type' ) )
					continue;
				if ( !isset( $col['title'] ) )
					$col['title'] = '';
				$new_cols[$id] = $col['title'];
			}
		}

		# Re-add any custom plugin columns:
		$custom   = array_diff_key( $cols, $this->_cols );
		$new_cols = array_merge( $new_cols, $custom );

		return $new_cols;

	}

	/**
	 * Output the column data for our custom columns.
	 *
	 * @param string $col The column name
	 * @param int $post_id The post ID
	 * @return null
	 */
	public function col( $col, $post_id ) {

		# Shorthand:
		$c = $this->args['cols'];

		# We're only interested in our custom columns:
		$custom_cols = array_filter( array_keys( $c ) );

		if ( !in_array( $col, $custom_cols ) )
			return;

		if ( isset( $c[$col]['function'] ) )
			call_user_func( $c[$col]['function'] );
		else if ( isset( $c[$col]['meta_key'] ) )
			$this->col_post_meta( $c[$col]['meta_key'], $c[$col] );
		else if ( isset( $c[$col]['taxonomy'] ) )
			$this->col_taxonomy( $c[$col]['taxonomy'] );
		else if ( isset( $c[$col]['post_field'] ) )
			$this->col_post_field( $c[$col]['post_field'] );
		else if ( isset( $c[$col]['featured_image'] ) )
			$this->col_featured_image( $c[$col]['featured_image'], $c[$col] );
		else if ( isset( $c[$col]['connection'] ) )
			$this->col_connection( $c[$col]['connection'], $c[$col] );

	}

	/**
	 * Output column data for a post meta field.
	 *
	 * @param string $meta_key The post meta key
	 * @param array $atts Optional array of 'width' and 'height' attributes for the image
	 * @return null
	 */
	public function col_post_meta( $meta_key, $atts = null ) {

		global $post;

		$val = get_post_meta( $post->ID, $meta_key, true );

		switch ( true ) {

			case isset( $atts['date_format'] ):

				if ( true === $atts['date_format'] )
					$atts['date_format'] = get_option( 'date_format' );

				if ( empty( $val ) )
					_e( 'none', 'ext_cpts' );
				else if ( is_numeric( $val ) )
					echo date( $atts['date_format'], $val );
				else
					echo mysql2date( $atts['date_format'], $val );

				break;

			default:

				echo esc_html( $val );

				break;

		}

	}

	/**
	 * Output column data for a taxonomy's term names.
	 *
	 * @param string $taxonomy The taxonomy name
	 * @return null
	 */
	public function col_taxonomy( $taxonomy ) {

		global $post;
		$terms = wp_get_object_terms( $post->ID, $taxonomy, array( 'fields' => 'names' ) );

		if ( is_wp_error( $terms ) or empty( $terms ) )
			return;

		echo implode( ', ', array_map( 'esc_html', $terms ) );

	}

	/**
	 * Output column data for a post field.
	 *
	 * @param string $field The post field
	 * @return null
	 */
	public function col_post_field( $field ) {

		global $post;

		switch ( $field ) {

			case 'post_date':
			case 'post_date_gmt':
				if ( '0000-00-00 00:00:00' == $post->$field )
					_e( 'Unpublished', 'ext_cpts' );
				else
					echo mysql2date( get_option( 'date_format' ), $post->$field );
				break;

			case 'post_modified':
			case 'post_modified_gmt':
				echo mysql2date( get_option( 'date_format' ), $post->$field );
				break;

			case 'post_status':
				$status = get_post_status_object( get_post_status( $post ) );
				echo $status->label;
				break;

			case 'post_author':
				echo get_the_author();
				break;

			default:
				echo esc_html( $post->$field );
				break;

		}

	}

	/**
	 * Output column data for a post's featured image.
	 *
	 * @param string $image_size The image size
	 * @param array $atts Optional array of 'width' and 'height' attributes for the image
	 * @return null
	 */
	public function col_featured_image( $image_size, $atts = null ) {

		if ( !function_exists( 'has_post_thumbnail' ) )
			return;

		$width  = isset( $atts['width'] )  ? $atts['width']  . 'px' : 'auto';
		$height = isset( $atts['height'] ) ? $atts['height'] . 'px' : 'auto';

		$image_atts = array(
			'style' => "width:{$width};height:{$height}",
			'title' => ''
		);

		if ( has_post_thumbnail() )
			the_post_thumbnail( $image_size, $image_atts );

	}

	/**
	 * Output column data for a Posts 2 Posts connection.
	 *
	 * @param string $connection The ID of the connection type
	 * @param array $args Optional array of arguments for a given connection type
	 * @return null
	 */
	public function col_connection( $connection, $args = null ) {

		global $post;

		if ( !function_exists( 'p2p_type' ) )
			return;

		$_post = $post;
		$meta = $connections = array();

		if ( isset( $args['field'] ) and isset( $args['value'] ) ) {
			$meta = array(
				'connected_meta' => array(
					$args['field'] => $args['value']
				)
			);
		}

		$connected = p2p_type( $connection )->get_connected( $post->ID, $meta );

		while ( $connected->have_posts() ) {
			$connected->the_post();
			$connections[] = get_the_title();
		}

		#wp_reset_postdata();
		$post = $_post;

		echo implode( ', ', array_map( 'esc_html', $connections ) );

	}

	/**
	 * Add our post type to the feed.
	 *
	 * This will fuck up individual post-type feeds. @TODO fix
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function add_to_feed( $vars ) {

		# If it's not a feed, we're not interested:
		if ( !isset( $vars['feed'] ) )
			return $vars;

		if ( !isset( $vars['post_type'] ) )
			$vars['post_type'] = array( 'post', $this->post_type );
		else if ( is_array( $vars['post_type'] ) )
			$vars['post_type'][] = $this->post_type;

		return $vars;

	}

	/**
	 * Add to or override our post type archive's private query vars.
	 *
	 * @param object $wp The WP request object
	 * @return object Updated WP request object
	 */
	public function override_private_query_vars( $wp ) {

		# If it's not our post type, bail out:
		if ( !isset( $wp->query_vars['post_type'] ) or ( $this->post_type != $wp->query_vars['post_type'] ) )
			return $wp;
		# If it's a single post, bail out:
		if ( isset( $wp->query_vars['name'] ) )
			return $wp;

		# Set the vars:
		foreach ( $this->args['archive'] as $var => $value )
			$wp->query_vars[$var] = $value;

		return $wp;

	}

	/**
	 * Add our post type archive link to the nav menus screen.
	 *
	 * @param array $posts Array of post objects and pseudo-post objects to show on the screen
	 * @param array $meta_box The meta box arguments
	 * @param array $post_type The current post type in the context of the nav menus screen
	 * @return array Updated array of posts and pseudo-posts
	 */
	public function nav_menu_items( $posts, $meta_box, $post_type ) {

		global $_nav_menu_placeholder;

		$pto = $post_type['args'];
		$_nav_menu_placeholder = ( 0 > $_nav_menu_placeholder ) ? intval( $_nav_menu_placeholder ) - 1 : -1;

		# Add our 'All Posts' item to the beginning of the list:
		array_unshift( $posts, (object) array(
			'ID'           => 0,
			'object_id'    => $_nav_menu_placeholder,
			'post_content' => '',
			'post_excerpt' => '',
			'post_parent'  => 0,
			'post_type'    => 'nav_menu_item',
			'post_title'   => $pto->labels->name,
			'label'        => $pto->labels->all_items,
			'type'         => 'custom',
			'url'          => get_post_type_archive_link( $this->post_type ),
		) );

		return $posts;

	}

	/**
	 * Logs the default columns so we don't remove any custom columns added by other plugins.
	 *
	 * @param array $cols The default columns for this post type screen
	 * @return array The default columns for this post type screen
	 */
	function _log_default_cols( $cols ) {

		return $this->_cols = $cols;

	}

	/**
	 * A non-localised version of _n()
	 *
	 * @param string $single The text that will be used if $number is 1
	 * @param string $plural The text that will be used if $number is not 1
	 * @param int $number The number to compare against to use either $single or $plural
	 * @return string Either $single or $plural text
	 */
	public function n( $single, $plural, $number ) {

		return ( 1 == $number ) ? $single : $plural;

	}

	/**
	 * Registers our post type.
	 *
	 * The only difference between this and regular register_post_type() calls is this will trigger
	 * an error of E_USER_ERROR level if a WP_Error is returned. Currently the only time you'll get
	 * an error from register_post_type() is if the post type name is too long.
	 *
	 * @return null
	 */
	public function register_post_type() {

		if ( is_wp_error( $cpt = register_post_type( $this->post_type, $this->args ) ) )
			trigger_error( $cpt->get_error_message(), E_USER_ERROR );

	}

}

?>