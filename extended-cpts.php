<?php
/*
Plugin Name:  Extended CPTs
Description:  Extended custom post types.
Version:      1.9.3
Author:       John Blackbourn
Author URI:   http://johnblackbourn.com

Extended CPTs provides extended functionality to custom post types in WordPress, allowing you to quickly build custom post types without having to write the same code again and again.

= Improved defaults =

 * Public post type with admin UI enabled
 * Intelligent values for labels and post updated messages
 * Hierarchical with page capability type
 * Drop with_front from rewrite rules
 * Support post thumbnails
 * Optimal menu placement

= Extended features =

 * Ridiculously easy custom admin columns:
   - Add columns for post meta, taxonomy terms, post fields, and callback functions
   - Out of the box sorting by post meta, taxonomy terms, and post fields
   - Specify a default sort column and sort order
 * Custom admin screen filters for post meta and taxonomy terms
 * Easily override any query variables such as posts_per_page, orderby, order and nopaging
 * Add post type archives to the nav menu screen
 * Add CPTs to the site's main feed
 * Add CPTs to the 'Right Now' section on the dashboard

= @TODO =

 * Improve the selection of fields in the Quick Edit boxes
 * Allow checkbox, radio and text input admin screen filters
 * Allow overriding of post updated messages via the $args parameter

= License =

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

*/


/**
 * Wrapper function for instantiating a new ExtendedCPT object. This is the only function you need.
 * See the ExtendedCPT class constructor for parameters.
 */
function register_extended_post_type( $post_type, $args = array(), $plural = null, $slug = null ) {
	return new ExtendedCPT( $post_type, $args, $plural, $slug );
}

class ExtendedCPT {

	/**
	 * Default arguments for custom post types.
	 * Many of these are different from those found in WordPress' register_post_type() function.
	 *
	 * @var array
	 */
	protected $defaults = array(
		'public'               => true,
		'publicly_queryable'   => true,
		'exclude_from_search'  => false,
		'show_ui'              => true,
		'show_in_menu'         => true,
		'menu_position'        => 6,
		'menu_icon'            => null,
		'capability_type'      => 'page',
		'hierarchical'         => true,
		'supports'             => array( 'title', 'editor', 'thumbnail' ),
		'has_archive'          => true,
		'query_var'            => true,
		'can_export'           => true,
		'show_in_nav_menus'    => true,
		'archive_in_nav_menus' => true,  # Custom arg
		'right_now'            => false, # Custom arg
		'show_in_feed'         => false, # Custom arg
		'archive'              => null,  # Custom arg
		'cols'                 => null,  # Custom arg
		'filters'              => null,  # Custom arg
	);

	/**
	 * Some other member variables you don't need to worry about:
	 */
	protected $post_type;
	protected $post_slug;
	protected $post_singular;
	protected $post_plural;
	protected $post_singular_low;
	protected $post_plural_low;
	protected $args;

	/**
	 * Class constructor.
	 *
	 * The $post_type parameter is used as the post type name and to build the post type labels. This
	 * means you can create a post type with just one parameter and all labels and post updated messages
	 * will be generated for you. Example:
	 *
	 * register_extended_post_type( 'event' );
	 *
	 * The plural name for a post type is generated by appending an 's' to $post_type. You can override
	 * this with the $plural parameter if necessary. Example:
	 *
	 * register_extended_post_type( 'person', array(), 'people' );
	 *
	 * The post type slug is generated from the plural (which is either $post_type appended with 's' or
	 * the $plural parameter). This can be overridden with the $slug parameter if necessary. Example:
	 *
	 * register_extended_post_type( 'person', array(), 'people', 'meet-the-team' );
	 *
	 * The $args parameter accepts all the standard arguments for register_post_type() in addition to
	 * several custom arguments that provide extended functionality:
	 *
	 * - archive_in_nav_menus - boolean - Whether to show an 'All Items' checkbox for this post type on
	 * the nav menus screen so the post type archive can easily be added to a nav menu without manually
	 * adding a custom link. Uses the 'all_items' label for the nav menus screen checkbox and the 'name'
	 * label for the actual menu item. Defaults to true. Only used if show_in_nav_menus and has_archive
	 * are both also true.
	 *
	 * - right_now - boolean - Whether to show this post type on the 'Right Now' section of WordPress'
	 * dashboard. Defaults to false.
	 *
	 * - show_in_feed - boolean - Whether to include this post type in the site's main feed. Defaults to
	 * false.
	 *
	 * - archive - array - An associative array of query vars to override on this post type's archive.
	 * Handy for setting 'no_paging' to true, for example. Defaults to null (no overridden query vars).
	 *
	 * - cols - array - An associative array of custom admin columns to show for this post type. See the
	 * cols() method of this class for more information. Defaults to null (no custom columns).
	 *
	 * - filters - array - An associative array of the admin filters to show for this post type. See the
	 * filters() method of this class for more information. Defaults to null (no custom filters).
	 *
	 * @param string $post_type The post type name
	 * @param array $args The post type arguments (optional)
	 * @param string $plural The post type plural name (optional)
	 * @param string $slug The post type slug (optional)
	 * @return null
	 */
	public function __construct( $post_type, $args = array(), $plural = null, $slug = null ) {

		$this->post_type = $post_type;

		if ( $slug )
			$this->post_slug = $slug;
		else if ( $plural )
			$this->post_slug = $plural;
		else
			$this->post_slug = $post_type . 's';

		if ( $plural )
			$this->post_plural = $plural;
		else
			$this->post_plural = $this->post_slug;

		# Build our base post type names:
		$this->post_singular     = ucwords( str_replace( array( '-', '_' ), ' ', $this->post_type ) );
		$this->post_plural       = ucwords( str_replace( array( '-', '_' ), ' ', $this->post_plural ) );
		$this->post_singular_low = strtolower( $this->post_singular );
		$this->post_plural_low   = strtolower( $this->post_plural );

		# Build our labels:
		$this->defaults['labels'] = array(
			'name'               => $this->post_plural,
			'singular_name'      => $this->post_singular,
			'menu_name'          => $this->post_plural,
			'name_admin_bar'     => $this->post_singular,
			'add_new'            => 'Add New',
			'add_new_item'       => sprintf( 'Add New %s', $this->post_singular ),
			'edit_item'          => sprintf( 'Edit %s', $this->post_singular ),
			'new_item'           => sprintf( 'New %s', $this->post_singular ),
			'view_item'          => sprintf( 'View %s', $this->post_singular ),
			'search_items'       => sprintf( 'Search %s', $this->post_plural ),
			'not_found'          => sprintf( 'No %s found', $this->post_plural_low ),
			'not_found_in_trash' => sprintf( 'No %s found in trash', $this->post_plural_low ),
			'parent_item_colon'  => sprintf( 'Parent %s', $this->post_singular ),
			'all_items'          => sprintf( 'All %s', $this->post_plural ),
		);

		# 'public' is a meta argument, so set some defaults if it's present:
		if ( isset( $args['public'] ) ) {
			$this->defaults['publicly_queryable']  =  $args['public'];
			$this->defaults['show_ui']             =  $args['public'];
			$this->defaults['show_in_menu']        =  $args['public'];
			$this->defaults['show_in_nav_menus']   =  $args['public'];
			$this->defaults['exclude_from_search'] = !$args['public'];
		}

		# 'show_ui' is a meta argument, so set some defaults if it's present:
		if ( isset( $args['show_ui'] ) )
			$this->defaults['show_in_menu'] = $args['show_ui'];

		# Only set rewrites if we need them
		if ( ( isset( $args['publicly_queryable'] ) and !$args['publicly_queryable'] ) or ( !$this->defaults['publicly_queryable'] ) ) {
			$this->defaults['rewrite'] = false;
		} else {
			$this->defaults['rewrite'] = array(
				'slug'       => $this->post_slug,
				'with_front' => false
			);
		}

		# Merge our args with the defaults:
		$this->args = wp_parse_args( $args, $this->defaults );

		# I can't remember why this is here, but it needs to be here:
		if ( !isset( $args['exclude_from_search'] ) )
			$this->args['exclude_from_search'] = !$this->args['publicly_queryable'];

		# This allows the 'labels' arg to contain some, none or all labels:
		if ( isset( $args['labels'] ) )
			$this->args['labels'] = wp_parse_args( $args['labels'], $this->defaults['labels'] );

		if ( is_admin() ) {

			# Admin columns:
			if ( $this->args['cols'] ) {
				add_action( "manage_{$this->post_type}_posts_columns",         array( $this, 'cols' ) );
				add_filter( "manage_{$this->post_type}_posts_custom_column",   array( $this, 'col' ), 10, 2 );
				add_filter( "manage_edit-{$this->post_type}_sortable_columns", array( $this, 'sortables' ) );
				add_action( 'load-edit.php',                                   array( $this, 'default_sort' ) );
				add_action( 'load-edit.php',                                   array( $this, 'maybe_sort' ) );
			}

			# Admin filters:
			if ( $this->args['filters'] ) {
				add_action( 'load-edit.php', array( $this, 'maybe_filter' ) );
				add_filter( 'query_vars',    array( $this, 'add_filter_query_vars' ) );
			}

			# 'Right Now' dashboard widget:
			if ( $this->args['right_now'] )
				add_action( 'right_now_content_table_end', array( $this, 'right_now' ) );

			# Nav menus screen item:
			if ( $this->args['archive_in_nav_menus'] and $this->args['show_in_nav_menus'] and $this->args['has_archive'] )
				add_action( "nav_menu_items_{$this->post_type}", array( $this, 'nav_menu_items' ), 10, 3 );

			# Post updated messages:
			add_filter( 'post_updated_messages',      array( $this, 'post_updated_messages' ), 1 );
			add_filter( 'bulk_post_updated_messages', array( $this, 'bulk_post_updated_messages' ), 1, 2 );

		} else {

			# Post type in the site's main feed:
			if ( $this->args['show_in_feed'] )
				add_filter( 'request', array( $this, 'add_to_feed' ) );

			# Post type archive query var overrides:
			if ( $this->args['archive'] )
				add_filter( 'parse_request', array( $this, 'override_private_query_vars' ), 1 );

		}

		# Register post type when WordPress initialises:
		if ( 'init' === current_filter() )
			call_user_func( array( $this, 'register_post_type' ) );
		else
			add_action( 'init', array( $this, 'register_post_type' ), 9 );

	}

	/**
	 * Set the default sort field and sort order on our post type admin screen.
	 *
	 * @return null
	 */
	public function default_sort() {

		#  If it's not our post type screen, bail out:
		if ( $this->post_type != get_current_screen()->post_type )
			return;

		# If we've already ordered the screen, bail out:
		if ( isset( $_GET['orderby'] ) )
			return;

		# Loop over our columns to find the default sort column (if there is one):
		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_array( $col ) and isset( $col['default'] ) ) {
				$_GET['orderby'] = $id;
				$_GET['order'] = ( 'desc' == strtolower( $col['default'] ) ? 'desc' : 'asc' );
				break;
			}
		}

	}

	/**
	 * Add the relevant filters for sorting posts by our sortable fields.
	 *
	 * @return null
	 */
	public function maybe_sort() {

		#  If it's not our post type screen, bail out:
		if ( $this->post_type != get_current_screen()->post_type )
			return;

		#  Add the necessary filters:
		add_filter( 'request',       array( $this, 'sort_posts_by_meta' ) );
		add_filter( 'request',       array( $this, 'sort_posts_by_field' ) );
		add_filter( 'posts_clauses', array( $this, 'sort_posts_by_tax' ), 10, 2 );

	}

	/**
	 * Add the relevant filters for filtering posts by our custom filters.
	 *
	 * @return null
	 */
	public function maybe_filter() {

		#  If it's not our post type screen, bail out:
		if ( $this->post_type != get_current_screen()->post_type )
			return;

		#  Add the necessary filters:
		add_filter( 'request',               array( $this, 'filter_posts_by_meta' ) );
		add_action( 'restrict_manage_posts', array( $this, 'filters' ) );

	}

	/**
	 * Output our custom filter dropdown menus on the admin screen.
	 *
	 * @TODO full filter docs
	 *
	 * @return null
	 */
	public function filters() {

		global $wpdb;

		foreach ( $this->args['filters'] as $filter_key => $filter ) {

			if ( isset( $filter['tax'] ) ) {

				$tax = get_taxonomy( $filter['tax'] );

				# We need the dropdown walker from Extended Taxonomies
				if ( !class_exists( $class = 'Walker_ExtendedTaxonomyDropdownSlug' ) )
					return trigger_error( sprintf( __( 'The %s class was not found', 'extended_taxonomies' ), $class ), E_USER_WARNING );
				else
					$walker = new Walker_ExtendedTaxonomyDropdownSlug;

				# If we haven't specified a title, use the all_items label:
				if ( !isset( $filter['title'] ) )
					$filter['title'] = $tax->labels->all_items;

				# Output the term dropdown menu:
				wp_dropdown_categories( array(
					'show_option_all' => $filter['title'] . '&nbsp;',
					'hide_empty'      => false,
					'hierarchical'    => true,
					'show_count'      => false,
					'orderby'         => 'name',
					'selected'        => get_query_var( $filter['tax'] ),
					'id'              => 'filter_' . $filter_key,
					'name'            => $filter['tax'],
					'taxonomy'        => $filter['tax'],
					'walker'          => $walker
				) );

			} else if ( isset( $filter['meta_key'] ) ) {

				# If we haven't specified a title, generate one from the meta key:
				if ( !isset( $filter['title'] ) ) {
					$filter['title'] = str_replace( array( '-', '_' ), ' ', $filter['meta_key'] );
					$filter['title'] = ucwords( $filter['title'] );
					$filter['title'] = sprintf( 'All %ss', $filter['title'] );
				}

				# Fetch all the values for our meta key:
				$meta_values = $wpdb->get_col( $wpdb->prepare( "
					SELECT DISTINCT meta_value
					FROM {$wpdb->postmeta} as m
					JOIN {$wpdb->posts} as p ON ( p.ID = m.post_id )
					WHERE m.meta_key = %s
					AND m.meta_value != ''
					AND p.post_type = %s
					ORDER BY m.meta_value ASC
				", $filter['meta_key'], $this->post_type ) );

				$selected = stripslashes( get_query_var( $filter_key ) );

				# Output the post meta dropdown:
				?>
				<select name="<?php echo esc_attr( $filter_key ); ?>" id="filter_<?php echo esc_attr( $filter_key ); ?>">
					<option value=""><?php echo esc_html( $filter['title'] ); ?>&nbsp;</option>
					<?php foreach ( $meta_values as $v ) { ?>
						<option value="<?php echo esc_attr( $v ); ?>" <?php selected( $selected, $v ); ?>><?php echo esc_html( $v ); ?></option>
					<?php } ?>
				</select>
				<?php

			}

		}

	}

	/**
	 * Add our post meta filter names to the public query vars.
	 *
	 * @param array $vars Public query variables
	 * @return array Updated public query variables
	 */
	public function add_filter_query_vars( $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {
			if ( isset( $filter['meta_key'] ) )
				$vars[] = $filter_key;
		}

		return $vars;

	}

	/**
	 * Add our post meta filters to the request parameters.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function filter_posts_by_meta( $vars ) {

		foreach ( $this->args['filters'] as $filter_key => $filter ) {
			if ( isset( $filter['meta_key'] ) and isset( $vars[$filter_key] ) and !empty( $vars[$filter_key] ) ) {
				$vars['meta_query'][] = array(
					'key'   => $filter['meta_key'],
					'value' => stripslashes( $vars[$filter_key] )
				);
			}
		}

		return $vars;

	}

	/**
	 * Add our post type to the 'Right Now' widget on WordPress' dashboard.
	 *
	 * @return null
	 */
	public function right_now() {

		# Get the labels and format the counts:
		$pto   = get_post_type_object( $this->post_type );
		$count = wp_count_posts( $this->post_type );
		$text  = $this->n( $pto->labels->singular_name, $pto->labels->name, $count->publish );
		$num   = number_format_i18n( $count->publish );

		# Add edit links if the user has permissions:
		if ( current_user_can( $pto->cap->edit_posts ) ) {
			$num  = '<a href="edit.php?post_type=' . $this->post_type . '">' . $num . '</a>';
			$text = '<a href="edit.php?post_type=' . $this->post_type . '">' . $text . '</a>';
		}

		# Output it:
		echo '<tr>';
		echo '<td class="first b b-' . $this->post_type . '">' . $num . '</td>';
		echo '<td class="t ' . $this->post_type . '">' . $text . '</td>';
		echo '</tr>';

	}

	/**
	 * Add our post type updated messages.
	 *
	 * The messages are as follows:
	 *
	 *   1 => "Post updated. {View Post}"
	 *   2 => "Custom field updated."
	 *   3 => "Custom field deleted."
	 *   4 => "Post updated."
	 *   5 => "Post restored to revision from [date]."
	 *   6 => "Post published. {View post}"
	 *   7 => "Post saved."
	 *   8 => "Post submitted. {Preview post}"
	 *   9 => "Post scheduled for: [date]. {Preview post}"
	 *  10 => "Post draft updated. {Preview post}"
	 *
	 * @param array $messages An associative array of post updated messages with post type as keys.
	 * @return array Updated array of post updated messages.
	 */
	public function post_updated_messages( $messages ) {

		global $post;

		$messages[$this->post_type] = array(
			1 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s updated. <a href="%2$s">View %3$s</a>' : '%1$s updated.' ),
				$this->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			2 => 'Custom field updated.',
			3 => 'Custom field deleted.',
			4 => sprintf( '%s updated.',
				$this->post_singular
			),
			5 => isset( $_GET['revision'] ) ? sprintf( '%1$s restored to revision from %2$s',
				$this->post_singular,
				wp_post_revision_title( intval( $_GET['revision'] ), false )
			) : false,
			6 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s published. <a href="%2$s">View %3$s</a>' : '%1$s published.' ),
				$this->post_singular,
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			7 => sprintf( '%s saved.',
				$this->post_singular
			),
			8 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s submitted. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s submitted.' ),
				$this->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->post_singular_low
			),
			9 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s scheduled for: <strong>%2$s</strong>. <a target="_blank" href="%3$s">Preview %4$s</a>' : '%1$s scheduled for: <strong>%2$s</strong>.' ),
				$this->post_singular,
				date_i18n( 'M j, Y @ G:i', strtotime( $post->post_date ) ),
				esc_url( get_permalink( $post->ID ) ),
				$this->post_singular_low
			),
			10 => sprintf( ( $this->args['publicly_queryable'] ? '%1$s draft updated. <a target="_blank" href="%2$s">Preview %3$s</a>' : '%1$s draft updated.' ),
				$this->post_singular,
				esc_url( add_query_arg( 'preview', 'true', get_permalink( $post->ID ) ) ),
				$this->post_singular_low
			),
		);

		return $messages;

	}

	/**
	 * Add our bulk post type updated messages.
	 *
	 * These messages are not yet in WordPress core.
	 * @see http://core.trac.wordpress.org/ticket/18710
	 *
	 * The messages are as follows:
	 *
	 *   1 => "Post updated." | "[n] posts updated."
	 *   2 => "Post not updated, somebody is editing it." | "[n] posts not updated, somebody is editing them."
	 *   3 => "Post permanently deleted." | "[n] posts permanently deleted."
	 *   4 => "Post moved to the trash." | "[n] posts moved to the trash."
	 *   5 => "Post restored from the trash." | "[n] posts restored from the trash."
	 *
	 * @param array $messages An associative array of bulk post updated messages with post type as keys.
	 * @return array Updated array of bulk post updated messages.
	 */
	public function bulk_post_updated_messages( $messages, $counts ) {

		$messages[$this->post_type] = array(
			1 => sprintf( $this->n( '%2$s updated.', '%1$s %3$s updated.', $counts[1] ),
				$counts[1],
				$this->post_singular,
				$this->post_plural_low
			),
			2 => sprintf( $this->n( '%2$s not updated, somebody is editing it.', '%1$s %3$s not updated, somebody is editing them.', $counts[2] ),
				$counts[2],
				$this->post_singular,
				$this->post_plural_low
			),
			3 => sprintf( $this->n( '%2$s permanently deleted.', '%1$s %3$s permanently deleted.', $counts[3] ),
				$counts[3],
				$this->post_singular,
				$this->post_plural_low
			),
			4 => sprintf( $this->n( '%2$s moved to the trash.', '%1$s %3$s moved to the trash.', $counts[4] ),
				$counts[4],
				$this->post_singular,
				$this->post_plural_low
			),
			5 => sprintf( $this->n( '%2$s restored from the trash.', '%1$s %3$s restored from the trash.', $counts[5] ),
				$counts[5],
				$this->post_singular,
				$this->post_plural_low
			),
		);

		return $messages;

	}

	/**
	 * Sort posts by post meta value.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_meta( $vars ) {

		if ( !isset( $vars['orderby'] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']]['meta_key'] ) )
			return $vars;

		$vars['meta_key'] = $this->args['cols'][$vars['orderby']]['meta_key'];
		$vars['orderby']  = 'meta_value';

		return $vars;

	}

	/**
	 * Sort posts by post field.
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function sort_posts_by_field( $vars ) {

		if ( !isset( $vars['orderby'] ) )
			return $vars;
		if ( !isset( $this->args['cols'][$vars['orderby']]['field'] ) )
			return $vars;

		$field = str_replace( 'post_', '', $this->args['cols'][$vars['orderby']]['field'] );
		$vars['orderby'] = $field;

		return $vars;

	}

	/**
	 * Sort posts by taxonomy term(s).
	 *
	 * @param array $clauses Request SQL clauses
	 * @param object $q The WP_Query object
	 * @return array Updated request SQL clauses
	 */
	public function sort_posts_by_tax( $clauses, $q ) {

		global $wpdb;

		if ( !isset( $q->query['orderby'] ) )
			return $clauses;
		if ( !isset( $this->args['cols'][$q->query['orderby']]['tax'] ) )
			return $clauses;

		# Taxonomy term ordering courtesy of http://scribu.net/wordpress/sortable-taxonomy-columns.html

		$clauses['join'] .= "
			LEFT OUTER JOIN {$wpdb->term_relationships} as extcpts_tr ON ( {$wpdb->posts}.ID = extcpts_tr.object_id )
			LEFT OUTER JOIN {$wpdb->term_taxonomy} as extcpts_tt ON ( extcpts_tr.term_taxonomy_id = extcpts_tt.term_taxonomy_id )
			LEFT OUTER JOIN {$wpdb->terms} as extcpts_t ON ( extcpts_tt.term_id = extcpts_t.term_id )
		";
		$clauses['where'] .= $wpdb->prepare( " AND ( taxonomy = %s OR taxonomy IS NULL )", $this->args['cols'][$q->query['orderby']]['tax'] );
		$clauses['groupby'] = 'extcpts_tr.object_id';
		$clauses['orderby'] = "GROUP_CONCAT( extcpts_t.name ORDER BY name ASC ) ";
		$clauses['orderby'] .= ( 'ASC' == strtoupper( $q->get('order') ) ) ? 'ASC' : 'DESC';

		return $clauses;

	}

	/**
	 * Add our custom columns to the list of sortable columns.
	 *
	 * @param array $cols Associative array of sortable columns
	 * @return array Updated array of sortable columns
	 */
	public function sortables( $cols ) {

		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_array( $col ) and ( isset( $col['meta_key'] ) or isset( $col['tax'] ) or isset( $col['field'] ) ) )
				$cols[$id] = $id;
		}

		return $cols;

	}

	/**
	 * Add our custom columns to the list of columns.
	 *
	 * @TODO full column docs
	 *
	 * @param array $cols Associative array of columns
	 * @return array Updated array of columns
	 */
	public function cols( $cols ) {

		$new_cols = array();
		$keep = array(
			'cb', 'title'
		);

		# Add the default columns we want to keep:
		foreach ( $cols as $id => $title ) {
			if ( in_array( $id, $keep ) )
				$new_cols[$id] = $title;
		}

		# Add our custom columns:
		foreach ( $this->args['cols'] as $id => $col ) {
			if ( is_string( $col ) and isset( $cols[$col] ) )
				$new_cols[$col] = $cols[$col];
			else if ( is_array( $col ) )
				$new_cols[$id] = $col['title'];
		}

		# Special support for the updated 'Page Manager' plugin:
		if ( post_type_supports( $this->post_type, 'reordering' ) and isset( $cols['verplaats'] ) )
			$new_cols['verplaats'] = $cols['verplaats'];

		return $new_cols;

	}

	/**
	 * Output the column data for our custom columns.
	 *
	 * @param string $col The column name
	 * @param int $post_id The post ID
	 * @return null
	 */
	public function col( $col, $post_id ) {

		# Shorthand:
		$c = $this->args['cols'];

		# We're only interested in our custom columns:
		$custom_cols = array_filter( array_keys( $c ) );

		if ( !in_array( $col, $custom_cols ) )
			return;

		if ( isset( $c[$col]['function'] ) )
			call_user_func( $c[$col]['function'] );
		else if ( isset( $c[$col]['meta_key'] ) )
			$this->col_meta( $c[$col]['meta_key'] );
		else if ( isset( $c[$col]['tax'] ) )
			$this->col_tax( $c[$col]['tax'] );
		else if ( isset( $c[$col]['field'] ) )
			$this->col_field( $c[$col]['field'] );

	}

	/**
	 * Output column data for a post meta field.
	 *
	 * @param string $meta_key The post meta key
	 * @param int $post_id The post ID
	 * @return null
	 */
	public function col_meta( $meta_key, $post_id = 0 ) {

		$post = get_post( $post_id );
		echo esc_html( get_post_meta( $post->ID, $meta_key, true ) );

	}

	/**
	 * Output column data for a taxonomy's term names.
	 *
	 * @param string $taxonomy The taxonomy name
	 * @param int $post_id The post ID
	 * @return null
	 */
	public function col_tax( $taxonomy, $post_id = 0 ) {

		$post  = get_post( $post_id );
		$terms = wp_get_object_terms( $post->ID, $taxonomy, array( 'fields' => 'names' ) );

		if ( is_wp_error( $terms ) or empty( $terms ) )
			return;

		echo implode( ', ', array_map( 'esc_html', $terms ) );

	}

	/**
	 * Output column data for a post field.
	 *
	 * @param string $field The post field
	 * @param int $post_id The post ID
	 * @return null
	 */
	public function col_field( $field, $post_id = 0 ) {

		$post       = get_post( $post_id );
		$full_field = 'post_' . $field;

		# This allows a field to be specified as 'post_{field}' or just '{field}':
		if ( isset( $post->$field ) )
			echo esc_html( $post->$field );
		else if ( isset( $post->$full_field ) )
			echo esc_html( $post->$full_field );

	}

	/**
	 * Add our post type to the feed.
	 *
	 * This will fuck up individual post-type feeds. @TODO fix
	 *
	 * @param array $vars Request parameters
	 * @return array Updated request parameters
	 */
	public function add_to_feed( $vars ) {

		# If it's not a feed, we're not interested:
		if ( !isset( $vars['feed'] ) )
			return $vars;

		if ( !isset( $vars['post_type'] ) )
			$vars['post_type'] = array( 'post', $this->post_type );
		else if ( is_array( $vars['post_type'] ) )
			$vars['post_type'][] = $this->post_type;

		return $vars;

	}

	/**
	 * Add to or override our post type archive's private query vars.
	 *
	 * @param object $wp The WP request object
	 * @return object Updated WP request object
	 */
	public function override_private_query_vars( $wp ) {

		# If it's not our post type, bail out:
		if ( !isset( $wp->query_vars['post_type'] ) or ( $this->post_type != $wp->query_vars['post_type'] ) )
			return $wp;
		# If it's a single post, bail out:
		if ( isset( $wp->query_vars['name'] ) )
			return $wp;

		# Set the vars:
		foreach ( $this->args['archive'] as $var => $value )
			$wp->query_vars[$var] = $value;

		return $wp;

	}

	/**
	 * Add our post type archive link to the nav menus screen.
	 *
	 * @param array $posts Array of post objects and pseudo-post objects to show on the screen
	 * @param array $meta_box The meta box arguments
	 * @param array $post_type The current post type in the context of the nav menus screen
	 * @return array Updated array of posts and pseudo-posts
	 */
	public function nav_menu_items( $posts, $meta_box, $post_type ) {

		global $_nav_menu_placeholder;

		$pto = $post_type['args'];
		$_nav_menu_placeholder = ( 0 > $_nav_menu_placeholder ) ? intval( $_nav_menu_placeholder ) - 1 : -1;

		# Add our 'All Posts' item to the beginning of the list:
		array_unshift( $posts, (object) array(
			'ID'           => 0,
			'object_id'    => $_nav_menu_placeholder,
			'post_content' => '',
			'post_excerpt' => '',
			'post_parent'  => 0,
			'post_type'    => 'nav_menu_item',
			'post_title'   => $pto->labels->name,
			'label'        => $pto->labels->all_items,
			'type'         => 'custom',
			'url'          => get_post_type_archive_link( $this->post_type ),
		) );

		return $posts;

	}

	/**
	 * A non-localised version of _n()
	 *
	 * @param string $single The text that will be used if $number is 1
	 * @param string $plural The text that will be used if $number is not 1
	 * @param int $number The number to compare against to use either $single or $plural
	 * @return string Either $single or $plural text
	 */
	public function n( $single, $plural, $number ) {

		return ( 1 == $number ) ? $single : $plural;

	}

	/**
	 * Registers our post type.
	 *
	 * The only difference between this and regular register_post_type() calls is this will trigger
	 * an error of E_USER_ERROR level if a WP_Error is returned. Currently the only time you'll get
	 * an error from register_post_type() is if the post type name is too long.
	 *
	 * @return null
	 */
	public function register_post_type() {

		if ( is_wp_error( $cpt = register_post_type( $this->post_type, $this->args ) ) )
			trigger_error( $cpt->get_error_message(), E_USER_ERROR );

	}

}

?>